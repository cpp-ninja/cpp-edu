Новые возможности в стандарте С++17 

1) Сруктуированные привязки (декопмопзиции) для распоковки набора значений
Эта функция помогает присваивать отдельные значения пар, кортежей и структур отдельным перменным. 

Пример:
```c++
auto [fraction, remainder] = divide_remainder(16,3)
std:cout << "16/3 is " << fraction <<" with a remainder" << reminder;

//Распаковка структуры
struct employee{
	unsigned id;
	std::string name;
	std::string role;
	unsigned salary;

};

std::vector<employee> employees {/* */};
for(const auto & [id, name. role, salary] : employees){
	cout<< "Name" << name << "Role:" << role << ...
}

```
Шаблон : `auto [var1, var2, var3, ...] = <выражение пары, кортежа, структуры или массива>`

2) Ограничение области видимости переменных в выражениях if и switch

Пример:
```c++
	if(auto itr(character_map.find(c)); itr != character_map.end()){
		// itr - корректен 
	}else {
		// itr - конечный итератор, не разыменовываем
	}
	// здесь itr недоступен

	switch(char c (getchar()); c ){
		case 'a' : move_left(); break;
		...
		...
		...
	}
```	
Шаблон:
```c++
	if(auto var (init_value)l condition){
		// Здесь к перменной можно получить доступ 
	}else{
		// Здесь к перменной можно получить доступ
	}
	// Здесь к перменной нельзя получить доступ
	



```
Это нужно чтобы бесполезные пермененные не попадали в общую область видимости, что делает код более удобочитаемым и компактным

3) Новые правила инициализатора с фигурными скобками // ?

4)автоматический вывод полученнего типа класса шаблона конструктором

Многие классы C++ обычно специализируются по типам, о чем легко догадаться по
типам переменных, которые пользователь задействует при вызовах конструктора.
Тем не менее до С++17 эти возможности не были стандартизированы. С++17 позво-
ляет компилятору автоматически вывести типы шаблонов из вызовов конструктора.

```C++
template <typename T1, typename T2, typename T3>
class my_wrapper {
	T1 t1;
	T2 t2;
	T3 t3;
public:
	explicit my_wrapper(T1 t1_, T2 t2_, T3 t3_): t1{t1_}, t2{t2_}, t3{t3_} {}
};
```
О’кей, это всего лишь еще один класс шаблона. Вот как мы раньше создавали
его объект (инстанцировали шаблон):
```C++
my_wrapper<int, double, const char *> wrapper {123, 1.23, "abc"};
```
Теперь же можно опустить специализацию шаблона:
```C++
my_wrapper wrapper {123, 1.23, "abc"};
```
5)Упрощаем принятие решений во время компиляции с помощью constexpr-if

```C++
	template <typename U>
	T add(U x) const {
		if constexpr (std::is_same_v<T, std::vector<U>>) {
			auto copy (val);
			for (auto &n : copy) {
				n += x;
			}
			return copy;
		} else {
			return val + x;
		}
}
```
Новая конструкция constexpr-if работает точно так же, как и обычные конструк-
ции if-else . Разница между ними заключается в том, что значение условного
выражения определяется во время компиляции. Весь код завершения, который
компилятор сгенерирует из нашей программы, не будет содержать дополнительных
ветвлений, относящихся к условиям constexpr-if

6) Свертка
```C++
template <typename ... Ts>
auto sum(Ts ... ts)
{
	return (ts + ...); //использование унарной свертки для суммы
}
```