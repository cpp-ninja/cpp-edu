

В C++ можно определить как константный указатель, так и
указатель на константу:
	int a = 10;
	const int * p1 = & a ; // указатель на константу
	int const * p2 = & a ; // указатель на константу
	* p1 = 20; // ошибка
	p2 = 0; // ОК
	
	int * const p3 = & a ; // константный указатель
	* p3 = 30; // OK
	p3 = 0; // ошибка

	// константный указатель на константу
	int const * const p4 = & a ;
	* p4 = 30; // ошибка
	p4 = 0; // ошибка


	Можно использовать следующее правило:
“слово const делает неизменяемым тип слева от него”.

	int a = 10;
	int * p = & a ;
	// указатель на указатель на const int
	int const ** p1 = & p ;

	// указатель на константный указатель на int
	int * const * p2 = & p ;

	// константный указатель на указатель на int
	int ** const p3 = & p ;


Ошибка заключается следующем присваивании: int const ** p1 = &p;  
В этой строчке я ожидаю, что значение типа int** (адрес переменной p) приведётся к значению типа int const**.
Если Вы попробуете скомпилировать этот код, то увидите, что он приводит к ошибке компиляции. Почему? Потому, что стандарт запрещает такие преобразования. Говоря точнее, стандартом разрешены (неявные) преобразования от T* к T const*, но не T** к T const**.

Почему бы не разрешить такие преобразования?

Оказывается, что, если бы такие преобразования были разрешены, то можно было бы изменить константные данные. Другими словами, система константности C++ была бы некорректна — она позволяла бы изменять неизменяемые данные.

Вопрос: как с помощью преобразования вида T** к T const** можно было бы изменить константные данные (если бы C++ позволял такие преобразования)?
 
Вот как это можно сделать:

	int const i = 1;
	int * p = 0;
	// p = &i;  не скомпилируется,  т.к. это преобразование int const * -> int *

	// В этой строке происходит запрещённое преобразование int ** -> int const **
	int const ** pp = &p;  // теперь *pp указывает на переменную p

	// следующая строка скомпилируется, т.к. *pp имеет тип int const*
	*pp = &i; // это соответствует p = &i
	*p = 2; // изменяем значение переменной i 