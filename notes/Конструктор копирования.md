Если не определить конструктор копирования или оператор присваивания они сгенерируется компилятором. 

В чем опасность такого поведения компилятора: По умолчаинию все члены классов копируются подрядю Поэтому если у нас есть какой-либо указатель на память выделенную динамически, то при выходе обоих обьектов из области видиимости, то есть при окончании времени жизни обьекта будет вызван деструктор оригинального класса и деструктор класса который мы копировали и выделенная память будет освобождена дважды, что приведеи к критической ошибке и выходу из программы. 


```c++
ClassName Obj1 = Obj2 // копирование  при вызове оператора присваивания
ClassName Obj3(Obj1) // Вызов конструктора копирования
```
Пример определения конструктора копирования:

```C++
struct IntArray {
	IntArray ( IntArray const& a ): size_(a.size_) , data_(new int [size_]){
		for ( size_t i = 0; i != size_ ; ++i )
			data_[i] = a.data_[i];
		}
...
private :
	size_t size_ ;
	int * data_ ;
};

```
Теперь data указывает на новую область памяти, удаление произойдет только один раз.

Пример определения опратора присваивания:

```c++
struct IntArray {

		IntArray & operator =( IntArray const & a ){
			if ( this != & a ) {
				delete [] data_ ;
				size_ = a.size_ ;
				data_ = new int [ size_ ];
				for ( size_t i = 0; i != size_ ; ++ i )
						data_[i] = a.data_[i];
			}
			return * this ;
	    }
...

};

``` 
Теперь data указывает на новую область памяти, удаление произойдет только один раз.
Чтобы данные не были удалены необходима проверка на то не присываиваем ли мы элемент самому себе. Возвращаем ссылку на обьект у которого только что выделили память и разместили элементы. За удаление элементов массива 'а' ответственен тот кто его создал.  


Компилятор генерирует четыре метода:
1. конструктор по умолчанию,
2. конструктор копирования,
3. оператор присваивания,
4. деструктор.
Если потребовалось переопределить конструктор копирования,
оператор присваивания или деструктор, то нужно
переопределить и остальные методы из этого списка.